import json
from pathlib import Path


NOTEBOOK_PATH = Path("ai_human_detector/face_auto_detector.ipynb")
TARGET_CELL_ID = "bad719f1"

NEW_SOURCE = [
    "import cv2\n",
    "import numpy as np\n",
    "import pyautogui\n",
    "import time\n",
    "import ctypes\n",
    "\n",
    "pyautogui.FAILSAFE = False\n",
    "pyautogui.PAUSE = 0\n",
    "\n",
    "face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + \"haarcascade_frontalface_default.xml\")\n",
    "\n",
    "# L-shape ROI based on your latest arrow image (normalized x, y)\n",
    "# Tune these points if camera angle changes.\n",
    "VERTICAL_ROI_NORM = np.array([\n",
    "    [0.11, 0.04],\n",
    "    [0.34, 0.04],\n",
    "    [0.34, 1.00],\n",
    "    [0.11, 1.00],\n",
    "], dtype=np.float32)\n",
    "\n",
    "HORIZONTAL_ROI_NORM = np.array([\n",
    "    [0.32, 0.20],\n",
    "    [0.79, 0.20],\n",
    "    [0.79, 0.43],\n",
    "    [0.32, 0.43],\n",
    "], dtype=np.float32)\n",
    "\n",
    "CAMERA_INDEX_CANDIDATES = (0, 1, 2)\n",
    "CAMERA_RESOLUTION_CANDIDATES = ((1280, 720), (960, 540), (640, 480))\n",
    "DETECT_MIN_SIZE = (12, 12)\n",
    "DETECT_MIN_NEIGHBORS = 2\n",
    "DETECT_SCALE_FACTOR = 1.03\n",
    "UPSCALE_FACTOR = 1.8\n",
    "UPSCALED_MIN_SIZE = (18, 18)\n",
    "\n",
    "BACKENDS = []\n",
    "if hasattr(cv2, \"CAP_MSMF\"):\n",
    "    BACKENDS.append((\"MSMF\", cv2.CAP_MSMF))\n",
    "if hasattr(cv2, \"CAP_DSHOW\"):\n",
    "    BACKENDS.append((\"DSHOW\", cv2.CAP_DSHOW))\n",
    "BACKENDS.append((\"ANY\", cv2.CAP_ANY))\n",
    "\n",
    "def to_pixels(points_norm, frame_w, frame_h):\n",
    "    pts = points_norm.copy()\n",
    "    pts[:, 0] *= frame_w\n",
    "    pts[:, 1] *= frame_h\n",
    "    return pts.astype(np.int32)\n",
    "\n",
    "def get_roi_polygons(frame_w, frame_h):\n",
    "    return [\n",
    "        to_pixels(VERTICAL_ROI_NORM, frame_w, frame_h),\n",
    "        to_pixels(HORIZONTAL_ROI_NORM, frame_w, frame_h),\n",
    "    ]\n",
    "\n",
    "def build_roi_mask(frame_h, frame_w, polygons):\n",
    "    mask = np.zeros((frame_h, frame_w), dtype=np.uint8)\n",
    "    for poly in polygons:\n",
    "        cv2.fillPoly(mask, [poly], 255)\n",
    "    return mask\n",
    "\n",
    "def box_iou(a, b):\n",
    "    ax1, ay1, aw, ah = a\n",
    "    bx1, by1, bw, bh = b\n",
    "    ax2, ay2 = ax1 + aw, ay1 + ah\n",
    "    bx2, by2 = bx1 + bw, by1 + bh\n",
    "\n",
    "    inter_x1 = max(ax1, bx1)\n",
    "    inter_y1 = max(ay1, by1)\n",
    "    inter_x2 = min(ax2, bx2)\n",
    "    inter_y2 = min(ay2, by2)\n",
    "\n",
    "    if inter_x2 <= inter_x1 or inter_y2 <= inter_y1:\n",
    "        return 0.0\n",
    "\n",
    "    inter = (inter_x2 - inter_x1) * (inter_y2 - inter_y1)\n",
    "    union = (aw * ah) + (bw * bh) - inter\n",
    "    if union <= 0:\n",
    "        return 0.0\n",
    "    return inter / union\n",
    "\n",
    "def nms(boxes, iou_threshold=0.25):\n",
    "    if not boxes:\n",
    "        return []\n",
    "\n",
    "    boxes = sorted(boxes, key=lambda b: b[2] * b[3], reverse=True)\n",
    "    kept = []\n",
    "    for box in boxes:\n",
    "        if all(box_iou(box, k) < iou_threshold for k in kept):\n",
    "            kept.append(box)\n",
    "    return kept\n",
    "\n",
    "def test_camera_stream(cap, tries=20, min_success=3):\n",
    "    success = 0\n",
    "    for _ in range(tries):\n",
    "        ok, _ = cap.read()\n",
    "        if ok:\n",
    "            success += 1\n",
    "            if success >= min_success:\n",
    "                return True\n",
    "        time.sleep(0.01)\n",
    "    return False\n",
    "\n",
    "def open_camera(preferred_index=None):\n",
    "    index_order = list(CAMERA_INDEX_CANDIDATES)\n",
    "    if preferred_index in index_order:\n",
    "        index_order.remove(preferred_index)\n",
    "        index_order.insert(0, preferred_index)\n",
    "\n",
    "    for idx in index_order:\n",
    "        for backend_name, backend in BACKENDS:\n",
    "            for width, height in CAMERA_RESOLUTION_CANDIDATES:\n",
    "                cap = cv2.VideoCapture(idx, backend)\n",
    "                if not cap.isOpened():\n",
    "                    cap.release()\n",
    "                    continue\n",
    "\n",
    "                cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)\n",
    "                cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)\n",
    "                cap.set(cv2.CAP_PROP_FPS, 30)\n",
    "                if hasattr(cv2, \"CAP_PROP_BUFFERSIZE\"):\n",
    "                    cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)\n",
    "                fourcc = cv2.VideoWriter_fourcc(*\"MJPG\")\n",
    "                cap.set(cv2.CAP_PROP_FOURCC, fourcc)\n",
    "\n",
    "                if test_camera_stream(cap):\n",
    "                    print(f\"[INFO] Camera opened (index={idx}, backend={backend_name}, size={width}x{height})\")\n",
    "                    return cap, idx\n",
    "\n",
    "                cap.release()\n",
    "    return None\n",
    "\n",
    "def minimize_desktop():\n",
    "    try:\n",
    "        pyautogui.hotkey(\"win\", \"d\")\n",
    "        return True\n",
    "    except Exception:\n",
    "        try:\n",
    "            user32 = ctypes.windll.user32\n",
    "            key_up = 0x0002\n",
    "            vk_lwin = 0x5B\n",
    "            vk_d = 0x44\n",
    "            user32.keybd_event(vk_lwin, 0, 0, 0)\n",
    "            user32.keybd_event(vk_d, 0, 0, 0)\n",
    "            user32.keybd_event(vk_d, 0, key_up, 0)\n",
    "            user32.keybd_event(vk_lwin, 0, key_up, 0)\n",
    "            return True\n",
    "        except Exception:\n",
    "            return False\n",
    "\n",
    "def detect_faces(gray, polygons, roi_mask):\n",
    "    all_boxes = []\n",
    "\n",
    "    for poly in polygons:\n",
    "        rx, ry, rw, rh = cv2.boundingRect(poly)\n",
    "        if rw < 10 or rh < 10:\n",
    "            continue\n",
    "\n",
    "        roi_gray = gray[ry:ry + rh, rx:rx + rw]\n",
    "        roi_mask_patch = roi_mask[ry:ry + rh, rx:rx + rw]\n",
    "        roi_gray = cv2.bitwise_and(roi_gray, roi_gray, mask=roi_mask_patch)\n",
    "\n",
    "        faces = face_cascade.detectMultiScale(\n",
    "            roi_gray,\n",
    "            scaleFactor=DETECT_SCALE_FACTOR,\n",
    "            minNeighbors=DETECT_MIN_NEIGHBORS,\n",
    "            minSize=DETECT_MIN_SIZE,\n",
    "        )\n",
    "\n",
    "        for (x, y, w, h) in faces:\n",
    "            all_boxes.append((x + rx, y + ry, w, h))\n",
    "\n",
    "        up = cv2.resize(roi_gray, None, fx=UPSCALE_FACTOR, fy=UPSCALE_FACTOR, interpolation=cv2.INTER_LINEAR)\n",
    "        up_faces = face_cascade.detectMultiScale(\n",
    "            up,\n",
    "            scaleFactor=DETECT_SCALE_FACTOR,\n",
    "            minNeighbors=DETECT_MIN_NEIGHBORS,\n",
    "            minSize=UPSCALED_MIN_SIZE,\n",
    "        )\n",
    "\n",
    "        for (x, y, w, h) in up_faces:\n",
    "            ox = int(x / UPSCALE_FACTOR) + rx\n",
    "            oy = int(y / UPSCALE_FACTOR) + ry\n",
    "            ow = int(w / UPSCALE_FACTOR)\n",
    "            oh = int(h / UPSCALE_FACTOR)\n",
    "            all_boxes.append((ox, oy, ow, oh))\n",
    "\n",
    "    merged = nms(all_boxes, iou_threshold=0.25)\n",
    "    faces_in_roi = []\n",
    "    for (x, y, w, h) in merged:\n",
    "        cx = x + w // 2\n",
    "        cy = y + h // 2\n",
    "        for poly in polygons:\n",
    "            if cv2.pointPolygonTest(poly, (float(cx), float(cy)), False) >= 0:\n",
    "                faces_in_roi.append((x, y, w, h))\n",
    "                break\n",
    "\n",
    "    return faces_in_roi\n",
    "\n",
    "opened = open_camera()\n",
    "if opened is None:\n",
    "    raise RuntimeError(\"Camera open failed. Close other apps using webcam and run again.\")\n",
    "\n",
    "cap, current_cam_index = opened\n",
    "print(\"보안 감시 가동 중... (Q를 누르면 종료)\")\n",
    "\n",
    "last_action_time = 0.0\n",
    "cooldown_sec = 5\n",
    "read_fail_count = 0\n",
    "reconnect_attempts = 0\n",
    "\n",
    "while True:\n",
    "    ret, frame = cap.read()\n",
    "\n",
    "    if not ret:\n",
    "        read_fail_count += 1\n",
    "        if read_fail_count % 20 == 0:\n",
    "            print(f\"[WARN] Frame read failed x{read_fail_count}\")\n",
    "\n",
    "        if read_fail_count >= 20:\n",
    "            reconnect_attempts += 1\n",
    "            print(f\"[WARN] Attempting camera reconnect #{reconnect_attempts}...\")\n",
    "            cap.release()\n",
    "            reopened = open_camera(preferred_index=current_cam_index)\n",
    "            if reopened is not None:\n",
    "                cap, current_cam_index = reopened\n",
    "                read_fail_count = 0\n",
    "                print(\"[INFO] Camera stream recovered\")\n",
    "                continue\n",
    "\n",
    "            if reconnect_attempts >= 10:\n",
    "                print(\"[ERROR] Camera stream could not be recovered. Exiting loop.\")\n",
    "                break\n",
    "\n",
    "            read_fail_count = 0\n",
    "\n",
    "        time.sleep(0.05)\n",
    "        continue\n",
    "\n",
    "    read_fail_count = 0\n",
    "    reconnect_attempts = 0\n",
    "\n",
    "    frame_h, frame_w = frame.shape[:2]\n",
    "    polygons = get_roi_polygons(frame_w, frame_h)\n",
    "    roi_mask = build_roi_mask(frame_h, frame_w, polygons)\n",
    "\n",
    "    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n",
    "    gray = cv2.equalizeHist(gray)\n",
    "\n",
    "    faces_in_roi = detect_faces(gray, polygons, roi_mask)\n",
    "\n",
    "    now = time.time()\n",
    "    if len(faces_in_roi) > 0 and (now - last_action_time) >= cooldown_sec:\n",
    "        print(f\"!!! Face detected in ROI ({len(faces_in_roi)}) !!!\")\n",
    "        if minimize_desktop():\n",
    "            print(\"[ACTION] Win+D executed\")\n",
    "        else:\n",
    "            print(\"[ERROR] Failed to execute Win+D\")\n",
    "        last_action_time = now\n",
    "\n",
    "    overlay = frame.copy()\n",
    "    for poly in polygons:\n",
    "        cv2.fillPoly(overlay, [poly], (40, 70, 140))\n",
    "    frame = cv2.addWeighted(overlay, 0.18, frame, 0.82, 0)\n",
    "\n",
    "    for poly in polygons:\n",
    "        cv2.polylines(frame, [poly], True, (255, 220, 0), 2)\n",
    "    for (x, y, w, h) in faces_in_roi:\n",
    "        cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)\n",
    "\n",
    "    cv2.imshow(\"Security Monitor\", frame)\n",
    "    if cv2.waitKey(1) & 0xFF == ord(\"q\"):\n",
    "        break\n",
    "\n",
    "cap.release()\n",
    "cv2.destroyAllWindows()\n",
]


def main() -> None:
    notebook = json.loads(NOTEBOOK_PATH.read_text(encoding="utf-8"))
    updated = False

    for cell in notebook.get("cells", []):
        if cell.get("id") == TARGET_CELL_ID:
            cell["source"] = NEW_SOURCE
            cell["execution_count"] = None
            cell["outputs"] = []
            updated = True
            break

    if not updated:
        raise RuntimeError(f"Target cell id not found: {TARGET_CELL_ID}")

    NOTEBOOK_PATH.write_text(
        json.dumps(notebook, ensure_ascii=False, indent=1) + "\n",
        encoding="utf-8",
    )


if __name__ == "__main__":
    main()
